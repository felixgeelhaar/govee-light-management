const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./feedback-DiKmv6ah.js","./vue-vendor-CA8X9H5U.js","./xstate-vendor-C3sHgvBT.js","../feedback.css"])))=>i.map(i=>d[i]);
var _=Object.defineProperty;var V=(o,e,t)=>e in o?_(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var u=(o,e,t)=>V(o,typeof e!="symbol"?e+"":e,t);import{d as W,c as $,f as T,e as x,k as v,K as Q,o as U,v as q,x as z,p as B,b as y,m as R,l as I,L as C}from"./vue-vendor-CA8X9H5U.js";import{_ as G}from"./feedback-DiKmv6ah.js";import{s as D,a as m,f as M,c as F}from"./xstate-vendor-C3sHgvBT.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function t(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=t(i);fetch(i.href,n)}})();const J="modulepreload",Y=function(o,e){return new URL(o,e).href},N={},j=function(e,t,s){let i=Promise.resolve();if(t&&t.length>0){let g=function(d){return Promise.all(d.map(c=>Promise.resolve(c).then(l=>({status:"fulfilled",value:l}),l=>({status:"rejected",reason:l}))))};const r=document.getElementsByTagName("link"),a=document.querySelector("meta[property=csp-nonce]"),h=a?.nonce||a?.getAttribute("nonce");i=g(t.map(d=>{if(d=Y(d,s),d in N)return;N[d]=!0;const c=d.endsWith(".css"),l=c?'[rel="stylesheet"]':"";if(!!s)for(let S=r.length-1;S>=0;S--){const w=r[S];if(w.href===d&&(!c||w.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${d}"]${l}`))return;const E=document.createElement("link");if(E.rel=c?"stylesheet":J,c||(E.as="script"),E.crossOrigin="",E.href=d,h&&E.setAttribute("nonce",h),document.head.appendChild(E),c)return new Promise((S,w)=>{E.addEventListener("load",S),E.addEventListener("error",()=>w(new Error(`Unable to preload CSS for ${d}`)))})}))}function n(r){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=r,window.dispatchEvent(a),!a.defaultPrevented)throw r}return i.then(r=>{for(const a of r||[])a.status==="rejected"&&n(a.reason);return e().catch(n)})},X={class:"govee-light-manager"},Z={class:"app-content"},ee=W({__name:"App",setup(o){const e=z({loader:()=>j(()=>import("./feedback-DiKmv6ah.js").then(s=>s.a),__vite__mapDeps([0,1,2,3]),import.meta.url),loadingComponent:void 0,delay:200,timeout:3e4,onError(s,i,n){console.error("Failed to load FeedbackSystem:",s),n()}}),t=v();return B("feedbackSystem",t),(s,i)=>{const n=Q("main-view");return U(),$("div",X,[i[0]||(i[0]=T("header",{class:"app-header"},[T("h1",null,"Govee Light Management")],-1)),T("main",Z,[x(n)]),x(q(e),{ref_key:"feedbackSystem",ref:t},null,512)])}}}),de=G(ee,[["__scopeId","data-v-5644db0e"]]);function b(o,e,t,s=!0){const i=new Error(o);return i.code=e,i.context=t,i.timestamp=Date.now(),i.recoverable=s,i}const A={WEBSOCKET_CONNECTION_FAILED:"WEBSOCKET_CONNECTION_FAILED",INVALID_INPUT:"INVALID_INPUT",SYSTEM_ERROR:"SYSTEM_ERROR"};function L(o,e){const t={message:o.message,stack:o.stack,code:"code"in o?o.code:void 0,timestamp:"timestamp"in o?o.timestamp:Date.now(),context:{..."context"in o?o.context:{},...e}};console.error("Application Error:",t)}class te{constructor(){u(this,"websocket",null);u(this,"port",null);u(this,"uuid",null);u(this,"registerEvent",null);u(this,"info",null);u(this,"actionInfo",null);u(this,"messageHandlers",new Map);u(this,"connectionHandlers",[])}initialize(e,t,s,i,n){this.port=e,this.uuid=t,this.registerEvent=s;try{this.info=JSON.parse(i),this.actionInfo=JSON.parse(n)}catch(r){console.error("Failed to parse Stream Deck initialization data:",r)}this.connect()}connect(){if(!this.port||!this.uuid||!this.registerEvent){const e=b("WebSocket service not properly initialized",A.WEBSOCKET_CONNECTION_FAILED,{port:this.port,uuid:this.uuid,registerEvent:this.registerEvent},!1);L(e);return}try{this.websocket=new WebSocket(`ws://localhost:${this.port}`),this.websocket.onopen=this.handleOpen.bind(this),this.websocket.onmessage=this.handleMessage.bind(this),this.websocket.onclose=this.handleClose.bind(this),this.websocket.onerror=this.handleError.bind(this)}catch(e){const t=b("Failed to create WebSocket connection",A.WEBSOCKET_CONNECTION_FAILED,{port:this.port,originalError:e});L(t)}}handleOpen(){if(console.log("WebSocket connected to Stream Deck"),this.websocket&&this.uuid&&this.registerEvent){const e={event:this.registerEvent,uuid:this.uuid};this.websocket.send(JSON.stringify(e))}this.connectionHandlers.forEach(e=>e(!0))}handleMessage(e){try{const t=JSON.parse(e.data);if(t.event==="didReceiveSettings"&&t.payload?.settings&&this.actionInfo&&(this.actionInfo.payload={...this.actionInfo.payload,settings:t.payload.settings}),t.event){const s=this.messageHandlers.get(t.event);s&&s.forEach(n=>n(t));const i=this.messageHandlers.get("*");i&&i.forEach(n=>n(t))}}catch(t){console.error("Failed to parse WebSocket message:",t)}}handleClose(){console.log("WebSocket disconnected from Stream Deck"),this.connectionHandlers.forEach(e=>e(!1)),setTimeout(()=>{this.port&&this.uuid&&this.registerEvent&&this.connect()},1e3)}handleError(e){const t=b("WebSocket connection error",A.WEBSOCKET_CONNECTION_FAILED,{originalError:e,port:this.port});L(t)}sendMessage(e){this.websocket&&this.websocket.readyState===WebSocket.OPEN?(console.log("WebSocketService: Sending message via WebSocket:",JSON.stringify(e)),this.websocket.send(JSON.stringify(e)),console.log("WebSocketService: Message sent successfully")):(console.warn("WebSocket not connected, cannot send message:",e),console.warn("WebSocket state:",this.websocket?.readyState),console.warn("Expected state (OPEN):",WebSocket.OPEN))}sendSettings(e){this.sendMessage({event:"sendToPlugin",context:this.uuid||"",payload:{event:"setSettings",settings:e}})}requestLights(){console.log("WebSocketService: requestLights called, sending getLights message"),console.log("WebSocket connection state:",this.websocket?.readyState),console.log("WebSocket.OPEN constant:",WebSocket.OPEN),console.log("Is connected:",this.isConnected);const e={event:"sendToPlugin",context:this.uuid||"",payload:{event:"getLights"}};console.log("Sending message:",JSON.stringify(e)),this.sendMessage(e)}requestGroups(){this.sendMessage({event:"sendToPlugin",context:this.uuid||"",payload:{event:"getGroups"}})}saveGroup(e){this.sendMessage({event:"sendToPlugin",context:this.uuid||"",payload:{event:"saveGroup",group:e}})}deleteGroup(e){this.sendMessage({event:"sendToPlugin",context:this.uuid||"",payload:{event:"deleteGroup",groupId:e}})}requestApiKeyStatus(){this.sendMessage({event:"sendToPlugin",context:this.uuid||"",payload:{event:"getApiKeyStatus"}})}validateApiKey(e){console.log("WebSocketService: validateApiKey called with key:",e?"present":"missing"),console.log("WebSocket state:",this.websocket?.readyState,"Expected OPEN:",WebSocket.OPEN),console.log("UUID:",this.uuid);const t={event:"sendToPlugin",context:this.uuid||"",payload:{event:"validateApiKey",apiKey:e}};console.log("WebSocketService: Sending validateApiKey message:",JSON.stringify(t)),this.sendMessage(t)}requestSettings(){this.sendMessage({event:"getSettings",context:this.uuid||""})}sendToPlugin(e){this.sendMessage({event:"sendToPlugin",context:this.uuid||"",payload:e})}on(e,t){this.messageHandlers.has(e)||this.messageHandlers.set(e,[]),this.messageHandlers.get(e).push(t)}off(e,t){const s=this.messageHandlers.get(e);if(s){const i=s.indexOf(t);i!==-1&&s.splice(i,1)}}onConnectionChange(e){this.connectionHandlers.push(e)}get isConnected(){return this.websocket?.readyState===WebSocket.OPEN}get getActionInfo(){return this.actionInfo}getCurrentSettings(){return this.actionInfo?.payload?.settings?this.actionInfo.payload.settings:null}get getInfo(){return this.info}disconnect(){this.websocket&&(this.websocket.close(),this.websocket=null)}}const f=new te;window.connectElgatoStreamDeckSocket=(o,e,t,s,i)=>{f.initialize(o,e,t,s,i)};class K{constructor(e){u(this,"cache",new Map);u(this,"accessQueue",[]);u(this,"stats",{hits:0,misses:0,evictions:0,totalRequests:0});u(this,"options",{ttl:300*1e3,maxSize:100,maxMemory:10*1024*1024});e&&(this.options={...this.options,...e}),setInterval(()=>this.cleanup(),120*1e3)}get(e){this.stats.totalRequests++;const t=this.cache.get(e);return t?this.isExpired(t)?(this.cache.delete(e),this.removeFromQueue(e),this.stats.misses++,null):(t.accessCount++,t.lastAccessed=Date.now(),this.updateAccessQueue(e),this.stats.hits++,t.data):(this.stats.misses++,null)}set(e,t,s){const i=s||this.options.ttl,n=Date.now(),r={data:t,timestamp:n,ttl:i,accessCount:1,lastAccessed:n};this.evictIfNeeded(),this.cache.set(e,r),this.updateAccessQueue(e)}has(e){const t=this.cache.get(e);return t!==void 0&&!this.isExpired(t)}delete(e){const t=this.cache.delete(e);return t&&this.removeFromQueue(e),t}clear(){this.cache.clear(),this.accessQueue=[],this.stats={hits:0,misses:0,evictions:0,totalRequests:0}}getStats(){const e=this.cache.size,t=this.stats.totalRequests>0?this.stats.hits/this.stats.totalRequests*100:0,s=100-t;let i=Date.now(),n=0,r=0;return this.cache.forEach(a=>{i=Math.min(i,a.timestamp),n=Math.max(n,a.timestamp),r+=JSON.stringify(a.data).length*2}),{entries:e,hitRate:Number(t.toFixed(2)),missRate:Number(s.toFixed(2)),memoryUsage:r,oldestEntry:i,newestEntry:n}}async getOrSet(e,t,s){const i=this.get(e);if(i!==null)return i;const n=await t();return this.set(e,n,s),n}invalidatePattern(e){const t=typeof e=="string"?new RegExp(e.replace(/\*/g,".*")):e;let s=0;const i=[];return this.cache.forEach((n,r)=>{t.test(r)&&i.push(r)}),i.forEach(n=>{this.delete(n)&&s++}),s}touch(e,t){const s=this.cache.get(e);return!s||this.isExpired(s)?!1:(s.ttl=t||this.options.ttl,s.timestamp=Date.now(),s.lastAccessed=Date.now(),this.updateAccessQueue(e),!0)}keys(){const e=[];return this.cache.forEach((t,s)=>{this.isExpired(t)||e.push(s)}),e}size(){return this.cache.size}getHealthStatus(){const e=this.getStats(),t=e.entries/this.options.maxSize*100,s=e.memoryUsage/this.options.maxMemory*100,i=[];let n="healthy";return t>90?(n="critical",i.push("Cache size critical - consider increasing maxSize or reducing TTL")):t>75&&(n="warning",i.push("Cache size approaching limit")),s>90?(n="critical",i.push("Memory usage critical - consider reducing cache size")):s>75&&(n="warning",i.push("Memory usage high")),e.hitRate<50&&this.stats.totalRequests>100&&i.push("Low hit rate - consider adjusting TTL or cache strategy"),{status:n,sizeUsage:Number(t.toFixed(2)),memoryUsage:Number(s.toFixed(2)),hitRate:Number(e.hitRate.toFixed(2)),size:e.entries,recommendations:i}}isExpired(e){return Date.now()-e.timestamp>e.ttl}updateAccessQueue(e){this.removeFromQueue(e),this.accessQueue.push(e)}removeFromQueue(e){const t=this.accessQueue.indexOf(e);t!==-1&&this.accessQueue.splice(t,1)}evictIfNeeded(){for(;this.cache.size>=this.options.maxSize&&this.accessQueue.length>0;){const t=this.accessQueue.shift();t&&(this.cache.delete(t),this.stats.evictions++)}const e=this.getStats();for(;e.memoryUsage>this.options.maxMemory&&this.accessQueue.length>0;){const t=this.accessQueue.shift();t&&(this.cache.delete(t),this.stats.evictions++)}}cleanup(){const e=[];this.cache.forEach((t,s)=>{this.isExpired(t)&&e.push(s)}),e.forEach(t=>{this.cache.delete(t),this.removeFromQueue(t)}),e.length>0&&console.log(`Cache cleanup: removed ${e.length} expired entries`)}}class se extends K{constructor(){super({ttl:120*1e3,maxSize:50,maxMemory:5*1024*1024})}cacheApiKeyValidation(e,t){const s=this.hashApiKey(e);this.set(`apikey:${s}`,t,600*1e3)}getCachedApiKeyValidation(e){const t=this.hashApiKey(e);return this.get(`apikey:${t}`)}cacheLights(e,t){const s=this.hashApiKey(e);this.set(`lights:${s}`,t,300*1e3)}getCachedLights(e){const t=this.hashApiKey(e);return this.get(`lights:${t}`)}cacheGroups(e,t){const s=this.hashApiKey(e);this.set(`groups:${s}`,t,180*1e3)}getCachedGroups(e){const t=this.hashApiKey(e);return this.get(`groups:${t}`)}invalidateApiKey(e){const t=this.hashApiKey(e);this.invalidatePattern(`*:${t}`)}hashApiKey(e){let t=0;for(let s=0;s<e.length;s++){const i=e.charCodeAt(s);t=(t<<5)-t+i,t=t&t}return Math.abs(t).toString(36)}}new K;const k=new se;class oe{constructor(){u(this,"metrics",[]);u(this,"activeOperations",new Map);u(this,"resourceHistory",[]);u(this,"maxMetrics",1e3);u(this,"maxHistory",100);u(this,"thresholds",{apiCall:5e3,uiOperation:100,cacheOperation:10,websocketMessage:1e3})}startTimer(e,t,s){const i={name:t,startTime:performance.now(),tags:s||{},metadata:{}};this.activeOperations.set(e,i)}endTimer(e,t){const s=this.activeOperations.get(e);if(!s){console.warn(`Performance timer not found: ${e}`);return}s.endTime=performance.now(),s.duration=s.endTime-s.startTime,s.metadata={...s.metadata,...t},this.activeOperations.delete(e),this.addMetric(s),this.checkPerformanceThresholds(s)}recordMetric(e,t,s,i){const n={name:e,startTime:performance.now()-t,endTime:performance.now(),duration:t,tags:s||{},metadata:i||{}};this.addMetric(n),this.checkPerformanceThresholds(n)}async timeAsync(e,t,s,i){this.startTimer(e,t,i);try{const n=await s();return this.endTimer(e,{success:!0}),n}catch(n){throw this.endTimer(e,{success:!1,error:n instanceof Error?n.message:"Unknown error"}),n}}timeSync(e,t,s,i){this.startTimer(e,t,i);try{const n=s();return this.endTimer(e,{success:!0}),n}catch(n){throw this.endTimer(e,{success:!1,error:n instanceof Error?n.message:"Unknown error"}),n}}recordResourceUsage(e){const t={memoryUsage:this.getMemoryUsage(),cacheHitRate:0,networkRequests:0,errorRate:this.calculateErrorRate(),timestamp:Date.now(),...e};this.resourceHistory.push(t),this.resourceHistory.length>this.maxHistory&&(this.resourceHistory=this.resourceHistory.slice(-this.maxHistory))}generateReport(e){let t=this.metrics;e&&(t=this.metrics.filter(c=>c.startTime>=e.start&&c.startTime<=e.end));const s=t.filter(c=>c.duration!==void 0);if(s.length===0)return{metrics:[],summary:{totalOperations:0,averageTime:0,slowestOperation:null,fastestOperation:null,operationsByType:{}},recommendations:["No performance data available"]};const i=s.map(c=>c.duration),n=s.length,r=i.reduce((c,l)=>c+l,0)/i.length,a=s.reduce((c,l)=>l.duration>c.duration?l:c),h=s.reduce((c,l)=>l.duration<c.duration?l:c),g={};s.forEach(c=>{g[c.name]=(g[c.name]||0)+1});const d=this.generateRecommendations(s);return{metrics:s,summary:{totalOperations:n,averageTime:Number(r.toFixed(2)),slowestOperation:a,fastestOperation:h,operationsByType:g},recommendations:d}}getBottlenecks(){const e=[],t=new Map;return this.metrics.forEach(s=>{s.duration!==void 0&&(t.has(s.name)||t.set(s.name,[]),t.get(s.name).push(s))}),t.forEach((s,i)=>{const n=s.map(c=>c.duration),r=n.reduce((c,l)=>c+l,0)/n.length,a=s.length;let h="low",g="";const d=this.getThresholdForOperation(i);r>d*2?(h="high",g=`${i} is very slow (${r.toFixed(2)}ms avg). Consider optimization.`):r>d?(h="medium",g=`${i} is slower than expected (${r.toFixed(2)}ms avg).`):r>d*.5&&(h="low",g=`${i} performance is acceptable but could be improved.`),h!=="low"&&e.push({type:"performance",severity:h,description:`${i} performance bottleneck`,impact:`Average response time: ${r.toFixed(2)}ms (${a} operations)`,recommendation:g,metrics:s})}),e.sort((s,i)=>{const n={critical:4,high:3,medium:2,low:1};return n[i.severity]-n[s.severity]})}getResourceTrends(){if(this.resourceHistory.length<2)return{memory:{trend:"stable",confidence:0,recommendation:"Insufficient data for analysis"},responseTime:{trend:"stable",confidence:0,recommendation:"Insufficient data for analysis"},throughput:{trend:"stable",confidence:0,recommendation:"Insufficient data for analysis"}};const e=this.resourceHistory.slice(-10),t=this.calculateTrend(e.map(i=>i.memoryUsage)),s=this.calculateTrend(e.map(i=>i.errorRate));return{memory:{trend:t,confidence:.8,recommendation:t==="increasing"?"Monitor memory usage":""},responseTime:{trend:s,confidence:.8,recommendation:s==="increasing"?"Investigate performance issues":""},throughput:{trend:"stable",confidence:.5,recommendation:"Monitoring throughput"}}}clear(){this.metrics=[],this.activeOperations.clear(),this.resourceHistory=[]}exportData(){return{metrics:this.metrics,resourceHistory:this.resourceHistory,report:this.generateReport(),bottlenecks:this.getBottlenecks(),trends:this.getResourceTrends()}}addMetric(e){this.metrics.push(e),this.metrics.length>this.maxMetrics&&(this.metrics=this.metrics.slice(-this.maxMetrics))}checkPerformanceThresholds(e){if(!e.duration)return;const t=this.getThresholdForOperation(e.name);e.duration>t*2&&console.warn(`Slow operation detected: ${e.name} took ${e.duration.toFixed(2)}ms (threshold: ${t}ms)`)}getThresholdForOperation(e){const t=e.toLowerCase();return t.includes("api")||t.includes("network")?this.thresholds.apiCall:t.includes("cache")?this.thresholds.cacheOperation:t.includes("websocket")||t.includes("message")?this.thresholds.websocketMessage:this.thresholds.uiOperation}generateRecommendations(e){const t=[],i=e.filter(a=>a.metadata?.success===!1).length/e.length*100;i>10&&t.push(`High error rate detected (${i.toFixed(1)}%) - investigate failing operations`);const n=new Map;e.forEach(a=>{n.set(a.name,(n.get(a.name)||0)+1)});const r=Array.from(n.entries()).filter(([a,h])=>h>e.length*.2).map(([a])=>a);return r.length>0&&t.push(`Consider caching for frequent operations: ${r.join(", ")}`),t}getMemoryUsage(){return"memory"in performance?performance.memory.usedJSHeapSize:0}calculateErrorRate(){const e=this.metrics.slice(-50);return e.length===0?0:e.filter(s=>s.metadata?.success===!1).length/e.length*100}calculateTrend(e){if(e.length<2)return"stable";const t=e[0],i=(e[e.length-1]-t)/t*100;return i>10?"increasing":i<-10?"decreasing":"stable"}}const P=new oe,ie=D({actions:{setApiKey:m({apiKey:({event:o})=>o.type==="CONNECT"?o.apiKey:""}),clearApiKey:m({apiKey:"",error:null}),setError:m({error:({event:o})=>o.type==="VALIDATION_FAILED"?o.error:null}),clearError:m({error:null}),startValidation:m({isValidating:!0}),stopValidation:m({isValidating:!1})},actors:{validateApiKey:M(async({input:o})=>{const e=`apikey-validation-${Date.now()}`;return P.timeAsync(e,"API Key Validation",async()=>{const t=k.getCachedApiKeyValidation(o.apiKey);if(t!==null)return console.log("API key validation result retrieved from cache"),t;if(!f.isConnected)throw new Error("WebSocket not connected to Stream Deck");return new Promise((s,i)=>{console.log("ApiConnectionMachine: Starting API key validation");const n=setTimeout(()=>{console.log("ApiConnectionMachine: Validation timeout after 10 seconds"),f.off("sendToPropertyInspector",r),i(new Error("API key validation timeout"))},1e4),r=a=>{console.log("ApiConnectionMachine: Received message:",JSON.stringify(a)),a.payload?.event==="apiKeyValidated"?(console.log("ApiConnectionMachine: Received apiKeyValidated response"),clearTimeout(n),f.off("sendToPropertyInspector",r),a.payload.isValid?(console.log("ApiConnectionMachine: API key validation successful"),k.cacheApiKeyValidation(o.apiKey,!0),s(!0)):(console.log("ApiConnectionMachine: API key validation failed:",a.payload.error),i(new Error(a.payload.error||"Invalid API key")))):console.log("ApiConnectionMachine: Received non-validation message:",a.payload?.event)};console.log("ApiConnectionMachine: Setting up response handler"),f.on("sendToPropertyInspector",r),console.log("ApiConnectionMachine: Sending validation request"),f.validateApiKey(o.apiKey)})},{operation:"api-validation"})})}}).createMachine({id:"apiConnection",initial:"disconnected",context:{apiKey:"",error:null,isValidating:!1},states:{disconnected:{on:{CONNECT:{target:"connecting",actions:["setApiKey","clearError"]}}},connecting:{entry:"startValidation",exit:"stopValidation",invoke:{src:"validateApiKey",input:({context:o})=>({apiKey:o.apiKey}),onDone:{target:"connected",actions:"clearError"},onError:{target:"error",actions:m({error:({event:o})=>o.error instanceof Error?o.error.message:String(o.error)})}},on:{VALIDATION_SUCCESS:{target:"connected",actions:"clearError"},VALIDATION_FAILED:{target:"error",actions:"setError"},DISCONNECT:{target:"disconnected",actions:"clearApiKey"}}},connected:{on:{DISCONNECT:{target:"disconnected",actions:"clearApiKey"}}},error:{on:{RETRY:{target:"connecting",actions:"clearError"},CONNECT:{target:"connecting",actions:["setApiKey","clearError"]},DISCONNECT:{target:"disconnected",actions:"clearApiKey"}}}}});function ue(){const o=v(null),e=v("disconnected"),t=v(""),s=v(null),i=v(!1),n=y(()=>e.value==="connected"),r=y(()=>e.value==="connecting"),a=y(()=>e.value==="disconnected"),h=y(()=>e.value==="error");R(()=>{o.value=F(ie),o.value.subscribe(l=>{e.value=l.value,t.value=l.context.apiKey,s.value=l.context.error,i.value=l.context.isValidating}),o.value.start()}),I(()=>{o.value&&o.value.stop()});const g=l=>{o.value&&o.value.send({type:"CONNECT",apiKey:l})},d=()=>{o.value&&o.value.send({type:"DISCONNECT"})},c=()=>{o.value&&o.value.send({type:"RETRY"})};return{state:y(()=>e.value),apiKey:y(()=>t.value),error:y(()=>s.value),isValidating:y(()=>i.value),isConnected:n,isConnecting:r,isDisconnected:a,hasError:h,connect:g,disconnect:d,retry:c}}const ne=D({actions:{setLights:m({lights:({event:o})=>o.type==="FETCH_SUCCESS"?o.lights:[],filteredLights:({event:o,context:e})=>o.type==="FETCH_SUCCESS"?e.searchQuery?o.lights.filter(t=>t.label.toLowerCase().includes(e.searchQuery.toLowerCase())):o.lights:[]}),setSearchQuery:m({searchQuery:({event:o})=>o.type==="SEARCH"?o.query:"",filteredLights:({event:o,context:e})=>{if(o.type==="SEARCH"){const t=o.query.toLowerCase();return e.lights.filter(s=>s.label.toLowerCase().includes(t))}return e.lights}}),setError:m({error:({event:o})=>o.type==="FETCH_FAILED"?o.error:null}),clearError:m({error:null}),startFetching:m({isFetching:!0}),stopFetching:m({isFetching:!1})},actors:{fetchLights:M(async({input:o})=>{const e=`lights-discovery-${Date.now()}`;return P.timeAsync(e,"Light Discovery",async()=>{const s=f.getCurrentSettings()?.apiKey;if(s){const i=k.getCachedLights(s);if(i)return console.log("Lights retrieved from cache"),i}if(!f.isConnected)throw new Error("WebSocket not connected to Stream Deck");return new Promise((i,n)=>{const r=setTimeout(()=>{f.off("sendToPropertyInspector",a),n(new Error("Light discovery timeout"))},15e3),a=h=>{if(h.payload?.event==="lightsReceived")if(clearTimeout(r),f.off("sendToPropertyInspector",a),h.payload.error)n(new Error(h.payload.error));else{const g=h.payload.lights||[];s&&g.length>0&&k.cacheLights(s,g),i(g)}};f.on("sendToPropertyInspector",a),console.log("LightDiscoveryMachine: About to call websocketService.requestLights()"),f.requestLights(),console.log("LightDiscoveryMachine: websocketService.requestLights() called")})},{operation:"light-discovery",cached:"false"})})}}).createMachine({id:"lightDiscovery",initial:"idle",context:({input:o})=>({lights:[],filteredLights:[],searchQuery:"",error:null,isFetching:!1}),states:{idle:{on:{FETCH:{target:"fetching"}}},fetching:{entry:["startFetching","clearError"],exit:"stopFetching",invoke:{src:"fetchLights",input:()=>({}),onDone:{target:"success",actions:[m({lights:({event:o})=>o.output,filteredLights:({event:o})=>o.output})]},onError:{target:"error",actions:m({error:({event:o})=>o.error?.message||"Unknown error"})}},on:{FETCH_SUCCESS:{target:"success",actions:"setLights"},FETCH_FAILED:{target:"error",actions:"setError"}}},success:{on:{REFRESH:{target:"fetching"},SEARCH:{actions:"setSearchQuery"}}},error:{on:{RETRY:{target:"fetching"}}}}});function ge(){const o=v(null),e=v("idle"),t=v([]),s=v([]),i=v(""),n=v(null),r=v(!1),a=y(()=>e.value==="idle"),h=y(()=>e.value==="fetching"),g=y(()=>e.value==="success"),d=y(()=>e.value==="error"),c=y(()=>t.value.length>0),l=y(()=>s.value.length>0);R(()=>{o.value=F(ne,{input:{}}),o.value.subscribe(p=>{console.log("useLightDiscovery: State change detected"),console.log("  State:",p.value),console.log("  Lights count:",p.context.lights.length),console.log("  Filtered lights count:",p.context.filteredLights.length),console.log("  Error:",p.context.error),console.log("  Is fetching:",p.context.isFetching),e.value=p.value,t.value=p.context.lights,s.value=p.context.filteredLights,i.value=p.context.searchQuery,n.value=p.context.error,r.value=p.context.isFetching,console.log("useLightDiscovery: Vue refs updated"),console.log("  isReady computed:",p.value==="success"),console.log("  hasLights computed:",p.context.lights.length>0),console.log("  hasFilteredLights computed:",p.context.filteredLights.length>0)}),o.value.start()}),I(()=>{o.value&&o.value.stop()});const O=()=>{console.log("useLightDiscovery: fetchLights called"),console.log("Actor exists:",!!o.value),o.value?(console.log("useLightDiscovery: Sending FETCH event to actor"),o.value.send({type:"FETCH"}),console.log("useLightDiscovery: FETCH event sent")):console.error("useLightDiscovery: Actor is null, cannot send FETCH event")},E=()=>{o.value&&o.value.send({type:"REFRESH"})},S=()=>{o.value&&o.value.send({type:"RETRY"})},w=p=>{o.value&&o.value.send({type:"SEARCH",query:p})},H=()=>{o.value&&o.value.send({type:"SEARCH",query:""})};return{state:C(e),lights:C(t),filteredLights:C(s),searchQuery:C(i),error:C(n),isFetching:C(r),isIdle:a,isFetchingLights:h,isReady:g,hasError:d,hasLights:c,hasFilteredLights:l,fetchLights:O,refreshLights:E,retryFetch:S,searchLights:w,clearSearch:H}}function pe(){typeof window<"u"&&(window.connectElgatoStreamDeckSocket=(o,e,t,s,i)=>{console.log("Initializing Stream Deck connection:",{port:o,uuid:e,registerEvent:t,info:JSON.parse(s),actionInfo:JSON.parse(i)}),f.initialize(o,e,t,s,i),re()})}function re(){f.on("didReceiveSettings",o=>{console.log("Received settings from plugin:",o.payload?.settings),typeof window<"u"&&window.dispatchEvent(new CustomEvent("streamDeckSettingsReceived",{detail:o.payload?.settings||{}}))}),f.on("sendToPropertyInspector",o=>{switch(console.log("Received message from plugin:",o.payload),o.payload?.event){case"lightsReceived":window.dispatchEvent(new CustomEvent("streamDeckLightsReceived",{detail:o.payload.lights||[]}));break;case"groupsReceived":window.dispatchEvent(new CustomEvent("streamDeckGroupsReceived",{detail:o.payload.groups||[]}));break;case"apiKeyValidated":window.dispatchEvent(new CustomEvent("streamDeckApiKeyValidated",{detail:{isValid:o.payload.isValid,error:o.payload.error}}));break;case"groupSaved":window.dispatchEvent(new CustomEvent("streamDeckGroupSaved",{detail:o.payload.group}));break;case"groupDeleted":window.dispatchEvent(new CustomEvent("streamDeckGroupDeleted",{detail:{groupId:o.payload.groupId}}));break;case"error":window.dispatchEvent(new CustomEvent("streamDeckError",{detail:{error:o.payload.error,operation:o.payload.operation}}));break}})}export{de as A,A as E,j as _,ge as a,b as c,pe as i,L as l,ue as u,f as w};
